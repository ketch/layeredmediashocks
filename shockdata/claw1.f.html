<!-- **** DO NOT EDIT THIS FILE *** 
         This file was generated automatically from file
              claw1.f
         using $CLAW/doc/clawcode2html.py         -->

<html>
<title> claw1.f.html </title>


           <BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" 
                 VLINK="#5500DD" ALINK="#FF0000">
           <font FACE="HELVETICA,ARIAL">
           
<!-- Created from the file /Users/ketch/Research/Projects/periodicshock/shockdata/claw1.f -->
<!-- Date: Tue Feb 15 2011 at 10:15:26 -->

<table bgcolor="#FFEE99"> <tr> <td>
<tr> <td><a href="http://www.clawpack.org"><img
            src="http://localhost:50005/doc/images/clawlogo.jpg"
            width=100 alt="CLAWPACK"></a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=6> claw1.f.html </font>
            </td><td>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; </td> </tr> <tr> <td>
&nbsp;Source file: &nbsp;&nbsp;<a href="claw1.f">claw1.f </a>
</td></tr><tr><td>
&nbsp;Directory:  &nbsp; /Users/ketch/Research/Projects/periodicshock/shockdata 
</td></tr><tr><td>
&nbsp;Converted:  &nbsp; Tue Feb 15 2011 at 10:15:26 
&nbsp; using <a href="http://localhost:50005/doc/clawcode2html.html">clawcode2html</a>
</td></tr><tr><td>
<font color="#BB3300"> &nbsp;This documentation file will 
not reflect any later changes in the source file. </font>
</td></tr></table></font>
<p>
<pre> 
<font color="blue">c</font>
<font color="blue">c     ==============================================================</font>
      subroutine claw1(maxmx,meqn,mwaves,mbc,mx,
     &           q,aux,xlower,dx,tstart,tend,dtv,cflv,nv,method,mthlim,
     &           mthbc,work,mwork,info,bc1,rp1,src1,b4step1)
<font color="blue">c     ==============================================================</font>
<font color="blue">c</font>
<font color="blue">c  Solves a hyperbolic system of conservation laws in one space dimension</font>
<font color="blue">c  of the general form </font>
<font color="blue">c</font>
<font color="blue">c     capa * q_t + A q_x = psi</font>
<font color="blue">c</font>
<font color="blue">c  The "capacity function" capa(x) and source term psi are optional</font>
<font color="blue">c  (see below).</font>
<font color="blue">c</font>
<font color="blue">c  For a more complete description see the documentation at</font>
<font color="blue">c      http://www.amath.washington.edu/~claw</font>
<font color="blue">c</font>
<font color="blue">c  Sample driver programs and user-supplied subroutines are available.</font>
<font color="blue">c  See the the directories claw/clawpack/1d/example* for some examples, and</font>
<font color="blue">c  codes in claw/applications for more extensive examples.</font>
<font color="blue">c</font>
<font color="blue">c  --------------------------------------------------------</font>
<font color="blue">c</font>
<font color="blue">c  The user must supply the following subroutines:</font>
<font color="blue">c</font>
<font color="blue">c    bc1, rp1        subroutines specifying the boundary conditions and </font>
<font color="blue">c                    Riemann solver.</font>
<font color="blue">c                    These are described in greater detail below.</font>
<font color="blue">c</font>
<font color="blue">c    b4step1            The routine b4step1 is called each time step and</font>
<font color="blue">c                       can be supplied by the user in order to perform</font>
<font color="blue">c                       other operations that are necessary every time</font>
<font color="blue">c                       step.  For example, if the variables stored in</font>
<font color="blue">c                       the aux arrays are time-dependent then these</font>
<font color="blue">c                       values can be set.</font>
<font color="blue">c</font>
<font color="blue">c  In addition, if the equation contains source terms psi, then the user</font>
<font color="blue">c  must provide:</font>
<font color="blue">c</font>
<font color="blue">c    src1               subroutine that solves capa * q_t = psi</font>
<font color="blue">c                       over a single time step.</font>
<font color="blue">c</font>
<font color="blue">c  These routines must be declared EXTERNAL in the main program.</font>
<font color="blue">c  For description of the calling sequences, see below.</font>
<font color="blue">c</font>
<font color="blue">c  Dummy routines b4step1.f and src1.f are available in </font>
<font color="blue">c       claw/clawpack/1d/lib</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c  Description of parameters...</font>
<font color="blue">c  ----------------------------</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c    maxmx is the maximum number of interior grid points in x, </font>
<font color="blue">c          and is used in declarations of the array q.</font>
<font color="blue">c</font>
<font color="blue">c    meqn is the number of equations in the system of</font>
<font color="blue">c         conservation laws.</font>
<font color="blue">c</font>
<font color="blue">c    mwaves is the number of waves that result from the</font>
<font color="blue">c           solution of each Riemann problem.  Often mwaves = meqn but</font>
<font color="blue">c           for some problems these may be different.</font>
<font color="blue">c</font>
<font color="blue">c    mbc is the number of "ghost cells" that must be added on to each</font>
<font color="blue">c       side of the domain to handle boundary conditions.  The cells</font>
<font color="blue">c       actually in the physical domain are labelled from 1 to mx in x.</font>
<font color="blue">c       The arrays are dimensioned actually indexed from 1-mbc to mx+mbc.</font>
<font color="blue">c       For the methods currently implemented, mbc = 2 should be used.</font>
<font color="blue">c       If the user implements another method that has a larger stencil and</font>
<font color="blue">c       hence requires more ghost cells, a larger value of mbc could be used.</font>
<font color="blue">c       q is extended from the physical domain to the ghost cells by the</font>
<font color="blue">c       user-supplied routine bc1.</font>
<font color="blue">c</font>
<font color="blue">c    mx is the number of grid cells in the x-direction, in the</font>
<font color="blue">c       physical domain.  In addition there are mbc grid cells</font>
<font color="blue">c       along each edge of the grid that are used for boundary</font>
<font color="blue">c       conditions.</font>
<font color="blue">c       Must have mx .le. maxmx</font>
<font color="blue">c </font>
<font color="blue">c    q(1-mbc:maxmx+mbc, meqn) </font>
<font color="blue">c        On input:  initial data at time tstart.</font>
<font color="blue">c        On output: final solution at time tend.</font>
<font color="blue">c        q(i,m) = value of mth component in the i'th cell.</font>
<font color="blue">c        Values within the physical domain are in q(i,m) </font>
<font color="blue">c                for i = 1,2,...,mx</font>
<font color="blue">c        mbc extra cells on each end are needed for boundary conditions</font>
<font color="blue">c        as specified in the routine bc1.</font>
<font color="blue">c</font>
<font color="blue">c    aux(1-mbc:maxmx+mbc, maux)</font>
<font color="blue">c        Array of auxiliary variables that are used in specifying the problem.</font>
<font color="blue">c        If method(7) = 0 then there are no auxiliary variables and aux</font>
<font color="blue">c                         can be a dummy variable.</font>
<font color="blue">c        If method(7) = maux > 0 then there are maux auxiliary variables</font>
<font color="blue">c                         and aux must be dimensioned as above.</font>
<font color="blue">c</font>
<font color="blue">c        Capacity functions are one particular form of auxiliary variable.</font>
<font color="blue">c        These arise in some applications, e.g. variable coefficients in</font>
<font color="blue">c        advection or acoustics problems.</font>
<font color="blue">c        See Clawpack Note # 5 for examples.</font>
<font color="blue">c</font>
<font color="blue">c        If method(6) = 0 then there is no capacity function.</font>
<font color="blue">c        If method(6) = mcapa > 0  then there is a capacity function and</font>
<font color="blue">c            capa(i), the "capacity" of the i'th cell, is assumed to be</font>
<font color="blue">c            stored in aux(i,mcapa).</font>
<font color="blue">c            In this case we require method(7).ge.mcapa.</font>
<font color="blue">c</font>
<font color="blue">c    dx = grid spacing in x.  </font>
<font color="blue">c         (for a computation in ax <= x <= bx,  set dx = (bx-ax)/mx.)</font>
<font color="blue">c</font>
<font color="blue">c    tstart = initial time.</font>
<font color="blue">c</font>
<font color="blue">c    tend = Desired final time (on input).</font>
<font color="blue">c              If tend<tstart, then claw1 returns after a single successful</font>
<font color="blue">c                 time step has been taken (single-step mode).</font>
<font color="blue">c              Otherwise, as many steps are taken as needed to reach tend, </font>
<font color="blue">c                 up to a maximum of nv(1).</font>
<font color="blue">c         = Actual time reached (on output).</font>
<font color="blue">c</font>
<font color="blue">c    dtv(1:5) = array of values related to the time step:</font>
<font color="blue">c               (Note: method(1)=1 indicates variable size time steps)</font>
<font color="blue">c         dtv(1) = value of dt to be used in all steps if method(1) = 0</font>
<font color="blue">c                = value of dt to use in first step if method(1) = 1</font>
<font color="blue">c         dtv(2) = unused if method(1) = 0.</font>
<font color="blue">c                = maximum dt allowed if method(1) = 1.</font>
<font color="blue">c         dtv(3) = smallest dt used (on output)</font>
<font color="blue">c         dtv(4) = largest dt used (on output)</font>
<font color="blue">c         dtv(5) = dt used in last step (on output)</font>
<font color="blue">c</font>
<font color="blue">c    cflv(1:4) = array of values related to Courant number:</font>
<font color="blue">c         cflv(1) = maximum Courant number to be allowed.  With variable</font>
<font color="blue">c                   time steps the step is repeated if the Courant</font>
<font color="blue">c                   number is larger than this value.  With fixed time</font>
<font color="blue">c                   steps the routine aborts.  Usually cflv(1)=1.0</font>
<font color="blue">c                   should work.</font>
<font color="blue">c         cflv(2) = unused if method(1) = 0.</font>
<font color="blue">c                 = desired Courant number if method(1) = 1.</font>
<font color="blue">c                   Should be somewhat less than cflv(1), e.g. 0.9</font>
<font color="blue">c         cflv(3) = largest Courant number observed (on output).</font>
<font color="blue">c         cflv(4) = Courant number in last step (on output).</font>
<font color="blue">c</font>
<font color="blue">c    nv(1:2) = array of values related to the number of time steps:</font>
<font color="blue">c         nv(1) = unused if method(1) = 0</font>
<font color="blue">c               = maximum number of time steps allowed if method(1) = 1</font>
<font color="blue">c         nv(2) = number of time steps taken (on output).</font>
<font color="blue">c</font>
<font color="blue">c    method(1:7) = array of values specifying the numerical method to use</font>
<font color="blue">c         method(1) = 0 if fixed size time steps are to be taken.</font>
<font color="blue">c                       In this case, dt = dtv(1) in all steps.</font>
<font color="blue">c                   = 1 if variable time steps are to be used.</font>
<font color="blue">c                       In this case, dt = dtv(1) in the first step and</font>
<font color="blue">c                       thereafter the value cflv(2) is used to choose the</font>
<font color="blue">c                       next time step based on the maximum wave speed seen</font>
<font color="blue">c                       in the previous step.  Note that since this value</font>
<font color="blue">c                       comes from the previous step, the Courant number will</font>
<font color="blue">c                       not in general be exactly equal to the desired value</font>
<font color="blue">c                       If the actual Courant number in the next step is</font>
<font color="blue">c                       greater than 1, then this step is redone with a </font>
<font color="blue">c                       smaller dt.</font>
<font color="blue">c</font>
<font color="blue">c         method(2) = 1 if Godunov's method is to be used, with no 2nd order</font>
<font color="blue">c                       corrections.</font>
<font color="blue">c                   = 2 if second order correction terms are to be added, with</font>
<font color="blue">c                       a flux limiter as specified by mthlim.  </font>
<font color="blue">c</font>
<font color="blue">c         method(3)  is not used in one-dimension.</font>
<font color="blue">c</font>
<font color="blue">c         method(4) = 0 to suppress printing</font>
<font color="blue">c                   = 1 to print dt and Courant number every time step</font>
<font color="blue">c</font>
<font color="blue">c         method(5) = 0 if there is no source term psi.  In this case</font>
<font color="blue">c                       the subroutine src1 is never called so a dummy</font>
<font color="blue">c                       parameter can be given.</font>
<font color="blue">c                   = 1 if there is a source term.  In this case</font>
<font color="blue">c                       the subroutine src1 must be provided and a</font>
<font color="blue">c                       fractional step method is used.</font>
<font color="blue">c                       In each time step the following sequence is followed:</font>
<font color="blue">c                            call bc to extend data to ghost cells</font>
<font color="blue">c                            call step1 to advance hyperbolic eqn by dt</font>
<font color="blue">c                            call src1 to advance source terms by dt</font>
<font color="blue">c                   = 2 if there is a source term and Strang splitting is to</font>
<font color="blue">c                       be used instead of the Godunov splitting above.</font>
<font color="blue">c                       In each time step the following sequence is followed:</font>
<font color="blue">c                            call bc to extend data to ghost cells</font>
<font color="blue">c                            call src1 to advance source terms by dt/2</font>
<font color="blue">c                            call step1 to advance hyperbolic equation by dt</font>
<font color="blue">c                            call src1 to advance source terms by dt/2</font>
<font color="blue">c                       For most problems 1 is recommended rather than 2</font>
<font color="blue">c                       since it is less expensive and works essentially as</font>
<font color="blue">c                       well on most problems.</font>

<font color="blue">c</font>
<font color="blue">c         method(6) = 0 if there is no capacity function capa.</font>
<font color="blue">c                   = mcapa > 0 if there is a capacity function.  In this case</font>
<font color="blue">c                       aux(i,mcapa) is the capacity of the i'th cell and you</font>
<font color="blue">c                       must also specify method(7) .ge. mcapa and set aux.</font>
<font color="blue">c</font>
<font color="blue">c         method(7) = 0 if there is no aux array used.</font>
<font color="blue">c                   = maux > 0  if there are maux auxiliary variables.</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c         The recommended choice of methods for most problems is</font>
<font color="blue">c            method(1) = 1,  method(2) = 2.</font>
<font color="blue">c</font>
<font color="blue">c    mthlim(1:mwaves) = array of values specifying the flux limiter to be used</font>
<font color="blue">c                     in each wave family mw.  Often the same value will be used</font>
<font color="blue">c                     for each value of mw, but in some cases it may be</font>
<font color="blue">c                     desirable to use different limiters.  For example,</font>
<font color="blue">c                     for the Euler equations the superbee limiter might be</font>
<font color="blue">c                     used for the contact discontinuity (mw=2) while another</font>
<font color="blue">c                     limiter is used for the nonlinear waves.  Several limiters</font>
<font color="blue">c                     are built in and others can be added by modifying the</font>
<font color="blue">c                     subroutine philim.</font>
<font color="blue">c</font>
<font color="blue">c        mthlim(mw) = 0 for no limiter</font>
<font color="blue">c                   = 1 for minmod</font>
<font color="blue">c                   = 2 for superbee</font>
<font color="blue">c                   = 3 for van Leer</font>
<font color="blue">c                   = 4 for monotonized centered</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c    work(mwork) = double precision work array of length at least mwork</font>
<font color="blue">c</font>
<font color="blue">c    mwork = length of work array.  Must be at least</font>
<font color="blue">c               (maxmx + 2*mbc) * (2 + 4*meqn + mwaves + meqn*mwaves)</font>
<font color="blue">c            If mwork is too small then the program returns with info = 4</font>
<font color="blue">c            and prints the necessary value of mwork to unit 6.</font>
<font color="blue">c</font>
<font color="blue">c            </font>
<font color="blue">c    info = output value yielding error information:</font>
<font color="blue">c         = 0 if normal return.</font>
<font color="blue">c         = 1 if mx.gt.maxmx   or  mbc.lt.2</font>
<font color="blue">c         = 2 if method(1)=0 and dt doesn't divide (tend - tstart).</font>
<font color="blue">c         = 3 if method(1)=1 and cflv(2) > cflv(1).</font>
<font color="blue">c         = 4 if mwork is too small.</font>
<font color="blue">c         = 11 if the code attempted to take too many time steps, n > nv(1).</font>
<font color="blue">c              This could only happen if method(1) = 1 (variable time steps).</font>
<font color="blue">c         = 12 if the method(1)=0 and the Courant number is greater than 1</font>
<font color="blue">c              in some time step.</font>
<font color="blue">c</font>
<font color="blue">c           Note: if info.ne.0, then tend is reset to the value of t actually</font>
<font color="blue">c           reached and q contains the value of the solution at this time.</font>
<font color="blue">c</font>
<font color="blue">c    User-supplied subroutines</font>
<font color="blue">c    -------------------------</font>
<font color="blue">c</font>
<font color="blue">c    bc1 = subroutine that specifies the boundary conditions.  </font>
<font color="blue">c         This subroutine should extend the values of q from cells</font>
<font color="blue">c         1:mx to the mbc ghost cells along each edge of the domain.</font>
<font color="blue">c</font>
<font color="blue">c          The form of this subroutine is</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c     subroutine bc1(maxmx,meqn,mbc,mx,xlower,dx,q,maux,aux,t,mthbc)</font>
<font color="blue">c     implicit double precision (a-h,o-z)</font>
<font color="blue">c     dimension   q(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c     dimension aux(1-mbc:maxmx+mbc, *)</font>
<font color="blue">c     dimension mthbc(2)</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c</font>
<font color="blue">c    The routine claw/clawpack/1d/lib/bc1.f can be used to specify</font>
<font color="blue">c    various standard boundary conditions.</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c    rp1 = user-supplied subroutine that implements the Riemann solver</font>
<font color="blue">c</font>
<font color="blue">c          The form of this subroutine is</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c     subroutine rp1(maxmx,meqn,mwaves,mbc,mx,ql,qr,auxl,auxr,wave,s,amdq,apdq)</font>
<font color="blue">c     implicit double precision (a-h,o-z)</font>
<font color="blue">c     dimension   ql(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c     dimension   qr(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c     dimension auxl(1-mbc:maxmx+mbc, *)</font>
<font color="blue">c     dimension auxr(1-mbc:maxmx+mbc, *)</font>
<font color="blue">c     dimension wave(1-mbc:maxmx+mbc, meqn, mwaves)</font>
<font color="blue">c     dimension    s(1-mbc:maxmx+mbc, mwaves)</font>
<font color="blue">c     dimension amdq(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c     dimension apdq(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c</font>
<font color="blue">c         On input, ql contains the state vector at the left edge of each cell</font>
<font color="blue">c                   qr contains the state vector at the right edge of each cell</font>
<font color="blue">c                 auxl contains auxiliary values at the left edge of each cell</font>
<font color="blue">c                 auxr contains auxiliary values at the right edge of each cell</font>
<font color="blue">c</font>
<font color="blue">c         Note that the i'th Riemann problem has left state qr(i-1,:)</font>
<font color="blue">c                                            and right state ql(i,:)</font>
<font color="blue">c         In the standard clawpack routines, this Riemann solver is</font>
<font color="blue">c         called with ql=qr=q along this slice.  More flexibility is allowed</font>
<font color="blue">c         in case the user wishes to implement another solution method</font>
<font color="blue">c         that requires left and rate states at each interface.</font>

<font color="blue">c         If method(7)=maux > 0 then the auxiliary variables along this slice</font>
<font color="blue">c         are passed in using auxl and auxr.  Again, in the standard routines</font>
<font color="blue">c         auxl=auxr=aux in the call to rp1.</font>
<font color="blue">c</font>
<font color="blue">c          On output, </font>
<font color="blue">c              wave(i,m,mw) is the m'th component of the jump across</font>
<font color="blue">c                              wave number mw in the ith Riemann problem.</font>
<font color="blue">c              s(i,mw) is the wave speed of wave number mw in the</font>
<font color="blue">c                              ith Riemann problem.</font>
<font color="blue">c              amdq(i,m) = m'th component of A^- Delta q,</font>
<font color="blue">c              apdq(i,m) = m'th component of A^+ Delta q,</font>
<font color="blue">c                     the decomposition of the flux difference</font>
<font color="blue">c                         f(qr(i-1)) - f(ql(i))</font>
<font color="blue">c                     into leftgoing and rightgoing parts respectively.</font>
<font color="blue">c</font>
<font color="blue">c           It is assumed that each wave consists of a jump discontinuity</font>
<font color="blue">c           propagating at a single speed, as results, for example, from a</font>
<font color="blue">c           Roe approximate Riemann solver.  An entropy fix can be included</font>
<font color="blue">c           into the specification of amdq and apdq.</font>
<font color="blue">c</font>
<font color="blue">c    src1 = subroutine for the source terms that solves the equation</font>
<font color="blue">c               capa * q_t = psi </font>
<font color="blue">c           over time dt.</font>
<font color="blue">c</font>
<font color="blue">c           If method(5)=0 then the equation does not contain a source</font>
<font color="blue">c           term and this routine is never called.  A dummy argument can</font>
<font color="blue">c           be used with many compilers, or provide a dummy subroutine that</font>
<font color="blue">c           does nothing (such a subroutine can be found in</font>
<font color="blue">c           claw/clawpack/1d/lib/src1.f)</font>
<font color="blue">c</font>
<font color="blue">c          The form of this subroutine is</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c     subroutine src1(maxmx,meqn,mbc,mx,xlower,dx,q,maux,aux,t,dt)</font>
<font color="blue">c     implicit double precision (a-h,o-z)</font>
<font color="blue">c     dimension   q(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c     dimension aux(1-mbc:maxmx+mbc, *)</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c      If method(7)=0  or the auxiliary variables are not needed in this solver,</font>
<font color="blue">c      then the latter dimension statement can be omitted, but aux should</font>
<font color="blue">c      still appear in the argument list.</font>
<font color="blue">c</font>
<font color="blue">c      On input, q(i,m) contains the data for solving the</font>
<font color="blue">c                source term equation.</font>
<font color="blue">c      On output, q(i,m) should have been replaced by the solution to</font>
<font color="blue">c                 the source term equation after a step of length dt.</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c      b4step1 = subroutine that is called from claw1 before each call to</font>
<font color="blue">c                step1.  Use to set time-dependent aux arrays or perform</font>
<font color="blue">c                other tasks which must be done every time step.</font>
<font color="blue">c</font>
<font color="blue">c          The form of this subroutine is</font>
<font color="blue">c      </font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c      subroutine b4step1(maxmx,mbc,mx,meqn,q,xlower,dx,time,dt,maux,aux)</font>
<font color="blue">c      implicit double precision (a-h,o-z)</font>
<font color="blue">c      dimension   q(1-mbc:maxmx+mbc, meqn)</font>
<font color="blue">c      dimension aux(1-mbc:maxmx+mbc, *)</font>
<font color="blue">c  -------------------------------------------------</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c =========================================================================</font>
<font color="blue">c</font>
<font color="blue">c  Copyright 1994 -- 2002 R. J. LeVeque</font>
<font color="blue">c</font>
<font color="blue">c  This software is made available for research and instructional use only. </font>
<font color="blue">c  You may copy and use this software without charge for these non-commercial</font>
<font color="blue">c  purposes, provided that the copyright notice and associated text is</font>
<font color="blue">c  reproduced on all copies.  For all other uses (including distribution of</font>
<font color="blue">c  modified versions), please contact the author at the address given below. </font>
<font color="blue">c  </font>
<font color="blue">c  *** This software is made available "as is" without any assurance that it</font>
<font color="blue">c  *** will work for your purposes.  The software may in fact have defects, so</font>
<font color="blue">c  *** use the software at your own risk.</font>
<font color="blue">c</font>
<font color="blue">c  --------------------------------------</font>
<font color="blue">c    CLAWPACK Version 4.1,  August, 2002</font>
<font color="blue">c    Webpage: http://www.amath.washington.edu/~claw</font>
<font color="blue">c  --------------------------------------</font>
<font color="blue">c    Author:  Randall J. LeVeque</font>
<font color="blue">c             Applied Mathematics</font>
<font color="blue">c             Box 352420</font>
<font color="blue">c             University of Washington, </font>
<font color="blue">c             Seattle, WA 98195-2420</font>
<font color="blue">c             rjl@amath.washington.edu</font>
<font color="blue">c =========================================================================</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c            </font>
<font color="blue">c    ======================================================================</font>
<font color="blue">c    Beginning of claw1 code</font>
<font color="blue">c    ======================================================================</font>
<font color="blue">c </font>
      implicit double precision (a-h,o-z)
      external bc1,rp1,src1,b4step1
      dimension q(1-mbc:maxmx+mbc, meqn)
      dimension aux(1-mbc:maxmx+mbc, *)
      dimension work(mwork)
      dimension mthlim(mwaves),method(7),dtv(5),cflv(4),nv(2)
      dimension mthbc(2)
      common /comxt/ dtcom,dxcom,tcom
<font color="blue">c</font>
<font color="blue">c</font>
      info = 0
      t = tstart
      maxn = nv(1)
      dt = dtv(1)   <font color="blue">!# initial dt</font>
      cflmax = 0.d0
      dtmin = dt
      dtmax = dt
      nv(2) = 0
      maux = method(7)
<font color="blue">c</font>
<font color="blue">c     # check for errors in data:</font>
<font color="blue">c</font>
      if (mx .gt. maxmx) then
         info = 1
         go to 900
         endif
<font color="blue">c</font>
      if (method(1) .eq. 0) then
<font color="blue">c        # fixed size time steps.  Compute the number of steps:</font>
         if (tend .lt. tstart) then
<font color="blue">c             # single step mode</font>
	      maxn = 1
           else
              maxn = (tend - tstart + 1d-10) / dt
              if (dabs(maxn*dt - (tend-tstart)) .gt.
     &                          1d-5*(tend-tstart)) then
<font color="blue">c                # dt doesn't divide time interval integer number of times</font>
                 info = 2
                 go to 900
                 endif
	   endif
         endif
<font color="blue">c</font>
      if (method(1).eq.1 .and. cflv(2).gt.cflv(1)) then
         info = 3
         go to 900
         endif
<font color="blue">c</font>
<font color="blue">c     # partition work array into pieces for passing into step1:</font>
      i0f = 1
      i0wave = i0f + (maxmx + 2*mbc) * meqn
      i0s = i0wave + (maxmx + 2*mbc) * meqn * mwaves
      i0dtdx = i0s + (maxmx + 2*mbc) * mwaves
      i0qwork = i0dtdx + (maxmx + 2*mbc) 
      i0amdq = i0qwork + (maxmx + 2*mbc) * meqn
      i0apdq = i0amdq + (maxmx + 2*mbc) * meqn
      i0dtdx = i0apdq + (maxmx + 2*mbc) * meqn
      i0end = i0dtdx + (maxmx + 2*mbc) - 1
<font color="blue">c</font>
      if (mwork .lt. i0end) then
         write(6,*) 'mwork must be increased to ',i0end
         info = 4
         go to 900
         endif
<font color="blue">c</font>
<font color="blue">c     -----------</font>
<font color="blue">c     # main loop</font>
<font color="blue">c     -----------</font>
<font color="blue">c</font>
      if (maxn.eq.0) go to 900
      do 100 n=1,maxn
         told = t   <font color="blue">!# time at beginning of time step.</font>

<font color="blue">c        # adjust dt to hit tend exactly if we're near end of computation</font>
<font color="blue">c        #  (unless tend < tstart, which is a flag to take only a single step)</font>
         if (told+dt.gt.tend .and. tstart.lt.tend) dt = tend - told

         if (method(1).eq.1) then
<font color="blue">c           # save old q in case we need to retake step with smaller dt:</font>
            call copyq1(maxmx,meqn,mbc,mx,q,work(i0qwork))
            endif
<font color="blue">c           </font>
   40    continue
         dt2 = dt / 2.d0
         thalf = t + dt2  <font color="blue">!# midpoint in time for Strang splitting</font>
         t = told + dt    <font color="blue">!# time at end of step</font>

<font color="blue">c        # store dt and t in the common block comxt in case they are needed</font>
<font color="blue">c        # in the Riemann solvers (for variable coefficients)</font>
         tcom = told
         dtcom = dt
         dxcom = dx
<font color="blue">c</font>
<font color="blue">c        ------------------------------------------------------------------</font>
<font color="blue">c        # main steps in algorithm:</font>
<font color="blue">c        ------------------------------------------------------------------</font>
<font color="blue">c</font>
<font color="blue">c        # extend data from grid to bordering boundary cells:</font>
         call bc1(maxmx,meqn,mbc,mx,xlower,dx,q,maux,aux,told,dt,mthbc)
<font color="blue">c</font>
<font color="blue">c</font>
<font color="blue">c        # call user-supplied routine which might set aux arrays</font>
<font color="blue">c        # for this time step, for example.</font>

         call b4step1(maxmx,mbc,mx,meqn,q,
     &                xlower,dx,told,dt,maux,aux)
<font color="blue">c</font>
<font color="blue">c</font>
         if (method(5).eq.2) then
<font color="blue">c            # with Strang splitting for source term:</font>
             call src1(maxmx,meqn,mbc,mx,xlower,dx,q,maux,aux,told,dt2)
             endif
<font color="blue">c</font>
<font color="blue">c        # take a step on the homogeneous conservation law:</font>
         call step1(maxmx,meqn,mwaves,mbc,mx,q,aux,dx,dt,
     &             method,mthlim,cfl,work(i0f),work(i0wave),
     &             work(i0s),work(i0amdq),work(i0apdq),work(i0dtdx),
     &             rp1)
<font color="blue">c</font>
         if (method(5).eq.2) then
<font color="blue">c            # source terms over a second half time step for Strang splitting:</font>
<font color="blue">c            # Note it is not so clear what time t should be used here if</font>
<font color="blue">c            # the source terms are time-dependent!</font>
             call src1(maxmx,meqn,mbc,mx,xlower,dx,q,maux,aux,thalf,dt2)
             endif

         if (method(5).eq.1) then
<font color="blue">c            # source terms over a full time step:</font>
             call src1(maxmx,meqn,mbc,mx,xlower,dx,q,maux,aux,t,dt)
             endif
<font color="blue">c</font>

<font color="blue">c</font>
<font color="blue">c        ------------------------------------------------------------------</font>
<font color="blue">c</font>
         if (method(4) .eq. 1) write(6,601) n,cfl,dt,t
  601    format('CLAW1... Step',i4,
     &                   '   Courant number =',f6.3,'  dt =',d12.4,
     &                   '  t =',d12.4)
<font color="blue">c</font>
         dt_used = dt
         if (method(1) .eq. 1) then
<font color="blue">c           # choose new time step if variable time step</font>
            if (cfl .gt. 0.d0) then
                dt = dmin1(dtv(2), dt * cflv(2)/cfl)
                dtmin = dmin1(dt,dtmin)
                dtmax = dmax1(dt,dtmax)
              else
                dt = dtv(2)
              endif
            endif
<font color="blue">c</font>
<font color="blue">c        # check to see if the Courant number was too large:</font>
<font color="blue">c</font>
         if (cfl .le. cflv(1)) then
<font color="blue">c               # accept this step</font>
                cflmax = dmax1(cfl,cflmax)
                call afterstep1(maxmx,mbc,mx,meqn,q,xlower,dx, 
     &                 t,dt_used,maux,aux)
              else
<font color="blue">c               # reject this step</font>
                t = told
                call copyq1(maxmx,meqn,mbc,mx,work(i0qwork),q)
<font color="blue">c</font>
                if (method(4) .eq. 1) then
                   write(6,602) 
  602              format('CLAW1 rejecting step... ',
     &                         'Courant number too large')
                   endif
                if (method(1).eq.1) then
<font color="blue">c                   # if variable dt, go back and take a smaller step</font>
                    go to 40
                  else
<font color="blue">c                   # if fixed dt, give up and return</font>
                    cflmax = dmax1(cfl,cflmax)
                    go to 900
                  endif
               endif
<font color="blue">c</font>
<font color="blue">c        # see if we are done:</font>
         nv(2) = nv(2) + 1
         if (t .ge. tend) go to 900
<font color="blue">c</font>
  100    continue
<font color="blue">c</font>
  900  continue
<font color="blue">c </font>
<font color="blue">c      # return information</font>
<font color="blue">c</font>
       if (method(1).eq.1 .and. t.lt.tend .and. nv(2) .eq. maxn) then
<font color="blue">c         # too many timesteps</font>
          info = 11
          endif
<font color="blue">c</font>
       if (method(1).eq.0 .and. cflmax .gt. cflv(1)) then
<font color="blue">c         # Courant number too large with fixed dt</font>
          info = 12
          endif
       tend = t
       cflv(3) = cflmax
       cflv(4) = cfl
       dtv(3) = dtmin
       dtv(4) = dtmax
       dtv(5) = dt
       return 
       end
</pre></html>
